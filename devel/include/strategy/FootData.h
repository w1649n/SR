// Generated by gencpp from file strategy/FootData.msg
// DO NOT EDIT!


#ifndef STRATEGY_MESSAGE_FOOTDATA_H
#define STRATEGY_MESSAGE_FOOTDATA_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace strategy
{
template <class ContainerAllocator>
struct FootData_
{
  typedef FootData_<ContainerAllocator> Type;

  FootData_()
    : LeftFootDistance(0)
    , RightFootDistance(0)
    , CenterFootDistance(0)
    , RightCenterFootDistance(0)
    , LeftCenterFootDistance(0)
    , Distance(0)
    , NextStairDistance(0)
    , LeftSlope2(0)
    , RightSlope2(0)
    , DangerLeftDistance(0)
    , DangerRightDistance(0)
    , LeftSlopeFlag(false)
    , RightSlopeFlag(false)
    , CenterSlopeFlag(false)
    , DangerLeftFlag(false)
    , DangerRightFlag(false)
    , RightFindWoodFlag(false)
    , LeftFindWoodFlag(false)  {
    }
  FootData_(const ContainerAllocator& _alloc)
    : LeftFootDistance(0)
    , RightFootDistance(0)
    , CenterFootDistance(0)
    , RightCenterFootDistance(0)
    , LeftCenterFootDistance(0)
    , Distance(0)
    , NextStairDistance(0)
    , LeftSlope2(0)
    , RightSlope2(0)
    , DangerLeftDistance(0)
    , DangerRightDistance(0)
    , LeftSlopeFlag(false)
    , RightSlopeFlag(false)
    , CenterSlopeFlag(false)
    , DangerLeftFlag(false)
    , DangerRightFlag(false)
    , RightFindWoodFlag(false)
    , LeftFindWoodFlag(false)  {
  (void)_alloc;
    }



   typedef int16_t _LeftFootDistance_type;
  _LeftFootDistance_type LeftFootDistance;

   typedef int16_t _RightFootDistance_type;
  _RightFootDistance_type RightFootDistance;

   typedef int16_t _CenterFootDistance_type;
  _CenterFootDistance_type CenterFootDistance;

   typedef int16_t _RightCenterFootDistance_type;
  _RightCenterFootDistance_type RightCenterFootDistance;

   typedef int16_t _LeftCenterFootDistance_type;
  _LeftCenterFootDistance_type LeftCenterFootDistance;

   typedef int16_t _Distance_type;
  _Distance_type Distance;

   typedef int16_t _NextStairDistance_type;
  _NextStairDistance_type NextStairDistance;

   typedef int16_t _LeftSlope2_type;
  _LeftSlope2_type LeftSlope2;

   typedef int16_t _RightSlope2_type;
  _RightSlope2_type RightSlope2;

   typedef int16_t _DangerLeftDistance_type;
  _DangerLeftDistance_type DangerLeftDistance;

   typedef int16_t _DangerRightDistance_type;
  _DangerRightDistance_type DangerRightDistance;

   typedef uint8_t _LeftSlopeFlag_type;
  _LeftSlopeFlag_type LeftSlopeFlag;

   typedef uint8_t _RightSlopeFlag_type;
  _RightSlopeFlag_type RightSlopeFlag;

   typedef uint8_t _CenterSlopeFlag_type;
  _CenterSlopeFlag_type CenterSlopeFlag;

   typedef uint8_t _DangerLeftFlag_type;
  _DangerLeftFlag_type DangerLeftFlag;

   typedef uint8_t _DangerRightFlag_type;
  _DangerRightFlag_type DangerRightFlag;

   typedef uint8_t _RightFindWoodFlag_type;
  _RightFindWoodFlag_type RightFindWoodFlag;

   typedef uint8_t _LeftFindWoodFlag_type;
  _LeftFindWoodFlag_type LeftFindWoodFlag;





  typedef boost::shared_ptr< ::strategy::FootData_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::strategy::FootData_<ContainerAllocator> const> ConstPtr;

}; // struct FootData_

typedef ::strategy::FootData_<std::allocator<void> > FootData;

typedef boost::shared_ptr< ::strategy::FootData > FootDataPtr;
typedef boost::shared_ptr< ::strategy::FootData const> FootDataConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::strategy::FootData_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::strategy::FootData_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::strategy::FootData_<ContainerAllocator1> & lhs, const ::strategy::FootData_<ContainerAllocator2> & rhs)
{
  return lhs.LeftFootDistance == rhs.LeftFootDistance &&
    lhs.RightFootDistance == rhs.RightFootDistance &&
    lhs.CenterFootDistance == rhs.CenterFootDistance &&
    lhs.RightCenterFootDistance == rhs.RightCenterFootDistance &&
    lhs.LeftCenterFootDistance == rhs.LeftCenterFootDistance &&
    lhs.Distance == rhs.Distance &&
    lhs.NextStairDistance == rhs.NextStairDistance &&
    lhs.LeftSlope2 == rhs.LeftSlope2 &&
    lhs.RightSlope2 == rhs.RightSlope2 &&
    lhs.DangerLeftDistance == rhs.DangerLeftDistance &&
    lhs.DangerRightDistance == rhs.DangerRightDistance &&
    lhs.LeftSlopeFlag == rhs.LeftSlopeFlag &&
    lhs.RightSlopeFlag == rhs.RightSlopeFlag &&
    lhs.CenterSlopeFlag == rhs.CenterSlopeFlag &&
    lhs.DangerLeftFlag == rhs.DangerLeftFlag &&
    lhs.DangerRightFlag == rhs.DangerRightFlag &&
    lhs.RightFindWoodFlag == rhs.RightFindWoodFlag &&
    lhs.LeftFindWoodFlag == rhs.LeftFindWoodFlag;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::strategy::FootData_<ContainerAllocator1> & lhs, const ::strategy::FootData_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace strategy

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::strategy::FootData_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::strategy::FootData_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::strategy::FootData_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::strategy::FootData_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::strategy::FootData_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::strategy::FootData_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::strategy::FootData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "8a34dd2dd0680c65b9684e60d7ed28ce";
  }

  static const char* value(const ::strategy::FootData_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x8a34dd2dd0680c65ULL;
  static const uint64_t static_value2 = 0xb9684e60d7ed28ceULL;
};

template<class ContainerAllocator>
struct DataType< ::strategy::FootData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "strategy/FootData";
  }

  static const char* value(const ::strategy::FootData_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::strategy::FootData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "int16 LeftFootDistance\n"
"int16 RightFootDistance\n"
"int16 CenterFootDistance\n"
"int16 RightCenterFootDistance\n"
"int16 LeftCenterFootDistance\n"
"int16 Distance\n"
"int16 NextStairDistance\n"
"int16 LeftSlope2\n"
"int16 RightSlope2\n"
"int16 DangerLeftDistance\n"
"int16 DangerRightDistance\n"
"bool LeftSlopeFlag\n"
"bool RightSlopeFlag\n"
"bool CenterSlopeFlag\n"
"bool DangerLeftFlag\n"
"bool DangerRightFlag\n"
"bool RightFindWoodFlag\n"
"bool LeftFindWoodFlag\n"
"\n"
;
  }

  static const char* value(const ::strategy::FootData_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::strategy::FootData_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.LeftFootDistance);
      stream.next(m.RightFootDistance);
      stream.next(m.CenterFootDistance);
      stream.next(m.RightCenterFootDistance);
      stream.next(m.LeftCenterFootDistance);
      stream.next(m.Distance);
      stream.next(m.NextStairDistance);
      stream.next(m.LeftSlope2);
      stream.next(m.RightSlope2);
      stream.next(m.DangerLeftDistance);
      stream.next(m.DangerRightDistance);
      stream.next(m.LeftSlopeFlag);
      stream.next(m.RightSlopeFlag);
      stream.next(m.CenterSlopeFlag);
      stream.next(m.DangerLeftFlag);
      stream.next(m.DangerRightFlag);
      stream.next(m.RightFindWoodFlag);
      stream.next(m.LeftFindWoodFlag);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct FootData_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::strategy::FootData_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::strategy::FootData_<ContainerAllocator>& v)
  {
    s << indent << "LeftFootDistance: ";
    Printer<int16_t>::stream(s, indent + "  ", v.LeftFootDistance);
    s << indent << "RightFootDistance: ";
    Printer<int16_t>::stream(s, indent + "  ", v.RightFootDistance);
    s << indent << "CenterFootDistance: ";
    Printer<int16_t>::stream(s, indent + "  ", v.CenterFootDistance);
    s << indent << "RightCenterFootDistance: ";
    Printer<int16_t>::stream(s, indent + "  ", v.RightCenterFootDistance);
    s << indent << "LeftCenterFootDistance: ";
    Printer<int16_t>::stream(s, indent + "  ", v.LeftCenterFootDistance);
    s << indent << "Distance: ";
    Printer<int16_t>::stream(s, indent + "  ", v.Distance);
    s << indent << "NextStairDistance: ";
    Printer<int16_t>::stream(s, indent + "  ", v.NextStairDistance);
    s << indent << "LeftSlope2: ";
    Printer<int16_t>::stream(s, indent + "  ", v.LeftSlope2);
    s << indent << "RightSlope2: ";
    Printer<int16_t>::stream(s, indent + "  ", v.RightSlope2);
    s << indent << "DangerLeftDistance: ";
    Printer<int16_t>::stream(s, indent + "  ", v.DangerLeftDistance);
    s << indent << "DangerRightDistance: ";
    Printer<int16_t>::stream(s, indent + "  ", v.DangerRightDistance);
    s << indent << "LeftSlopeFlag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.LeftSlopeFlag);
    s << indent << "RightSlopeFlag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.RightSlopeFlag);
    s << indent << "CenterSlopeFlag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.CenterSlopeFlag);
    s << indent << "DangerLeftFlag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.DangerLeftFlag);
    s << indent << "DangerRightFlag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.DangerRightFlag);
    s << indent << "RightFindWoodFlag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.RightFindWoodFlag);
    s << indent << "LeftFindWoodFlag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.LeftFindWoodFlag);
  }
};

} // namespace message_operations
} // namespace ros

#endif // STRATEGY_MESSAGE_FOOTDATA_H
